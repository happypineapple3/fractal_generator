# Software Development Plan

## Phase 0: Requirements Analysis (tag name `analyzed`)
*(20% of your effort)*

**Important - do not change the code in this phase**

Deliver:

*   [X] Re-write the instructions in your own words.
    *   If you don't do this, you won't know what you're supposed to do!
    *   Don't leave out details!
## Rewrite the instructions
* My job with this assignment is to refactor a program that has already been made and that already works. The output
is as expected already, and there's nothing with it that I need to fix; the program is sloppily written, however, so it
is my job to fix that and make it easier to read and understand. As part of that, I need to separate the code into
6 different modules, each one being:
	* main.py
	* FractalInformation.py
	* Mandelbrot.py
	* Phoenix.py
	* Palette.py
	* ImagePainter.py
* In addition to separating the code, I need to identify code smells that are contained
in the program. With each code smell, I need to document it, explain why it's not good,
and describe how I will fix it. 
* Both of these tasks are intended to help improve the general readability of the program.
At the end of the day, that is the main goal of this assignment.
	* Some other practices that will help me achieve this goal will be running
	tests constantly to ensure that I haven't accidentally added a bug to the code.
	Every time that I make a change, I should run the program to make sure that
	nothing was affected by my change.
	* Another specific change that I've been asked to make is uniting the mandelbrot
	and phoenix dictionaries into a single dictionary.
* It also falls into my responsibility to draw a new UML Class Diagram representing
the modules that I will be separating the code into. This should mimic an actual class
diagram while getting the point across.
* Finally, I need to write a user's manual explaining how to use this program. I don't
expect this to be difficult at all, but I just need to remember to do it. 


*   [X] Explain the problem this program aims to solve.
    *   Describe what a *good* solution looks like.
    *   List what you already know how to do.
    *   Point out any challenges that you can foresee.
## Explain the problem this program aims to solve
* This program already does what it's supposed to do, but it's sloppily written and
difficult to understand. Its smelliness is the problem at hand, and that is what
must be fixed. It needs to change from smelly to refreshing.
### Describe what a *good* solution looks like.
* A good solution will follow the project requirements with regards to how to separate
the code. At the end of the day, the program should be comprised of six modules with
each module performing its own task. Any dead or redundant code will be removed, magic
numbers will be identified and replaced with global variables, and functions that perform
more than one task will be separated. Once the code is refactored, everything should
still work exactly the same; there should be no differences before and after.
### What I already know how to do
* I learned how dictionaries work because of previous assignments, so I feel
confident in my ability to combine the two dictionaries into one.
* I know how to identify code smells and what to look for, so I don't expect it to be
too difficult completing that aspect of the assignment.
* I can work with sys.argv to find the number of arguments in a command and run
the program according to those arguments.
* I know how to run the program; this will make it very easy to write the user's
manual for this program.
### Challenges that I can foresee
* In the past I've struggled properly separating code into modules. I do expect it
to take some time to really figure out what code goes where and what to import into
other modules so that the program will keep working.
* Separating functions that do too much into smaller functions. I think I'll have a 
hard time determing if a function even does have multiple roles and then separating 
it so that those roles stay separate.
* I expect it to be difficult just understanding how the code works. I'll need to take
my time reading it and playing around with it before I'll feel ready to start changing
how it's written. 
* I still don't really understand UML Diagrams, so I'll need to take time and get it
made well before the due date so that I can get help with it.
* I don't feel comfortable with tkinter, so I'm going to need to take some time to familiarize
myself with that and how it works. 

*   [X] List all of the data that is used by the program, making note of where it comes from.
    *   Explain what form the output will take.
## List all the data to be used by the program
* Nearly all of the data used in the program will already be provided by the program. 
The only data that is provided by the user is when the user inputs which fractal
the user would like to see. This data is pulled in by sys.argv and incorporated
into the program. 
* The program uses a predefined list of colors that gets called on to draw the
fractals.
* Dictionaries are used by phoenix.py and mandelbrot.py as means of knowing which
fractal to draw when the input is provided by the user.
* Calculations are used within the program to determine the difference between phoenix
and mandelbrot fractals. These numbers are provided by the programmer and never 
introduced to the user.
* The program relies on complex numbers to draw the fractals. These complex numbers
are computed within the program and require no further work to function.
* Tkinter takes each pixel and colors it according to the iteration count (phoenix 
or mandelbrot). The color comes from the aforementioned list of colors.
### Form of the output
* The output for this program is quite simple. Depending on the fractal that the user
selects, tkinter opens another window and produces an image that represents the 
selected fractal. A png image is saved to the directory from where the user ran the
program.
* The terminal prints out the continues status of the progress of the image until
the image is completed. The user is then told to exit out of the tkinter window in
order for the program to finish running.

*   [X] List the algorithms that will be used (but don't write them yet).
## List of algorithms to be used
* a function to get a color from the palette (list of colors)
* a function to return the fractal from a dictionary
* a function that will take a fractal and paint an image of it
* a function that will take the sys.argv arguments and run the program according
to the user.
* a function that will act as the main driver for the entire program.

*   [X] Tag the last commit in this phase `analyzed`
    *   *Grace Points: if this tag is pushed by midnight on the Sunday before the due date, you will receive up to 5 points back*


## Phase 1: Design (tag name `designed`)
*(30% of your effort)*

**Important - do not change the code in this phase**

Deliver:

*   [ ] Function signatures that include:
    *   Descriptive names.
    *   Parameter lists.
    *   Documentation strings that explain its purpose and types of inputs and outputs.
*   [ ] Pseudocode that captures how each function works.
    *   Pseudocode != source code.  Do not paste your finished source code into this part of the plan.
*   Explain what happens in the face of good and bad input.
    *   Write a few specific examples that occur to you, and use them later when testing
*   [ ] Tag the last commit in this phase `designed`
    *   *Grace Points: if this tag is pushed by midnight on the Sunday before the due date, you will receive up to 5 points back*


## Phase 2: Implementation (tag name `implemented`)
*(15% of your effort)*

**Finally, you can write code!**

Deliver:

*   [ ] More or less working code.
*   [ ] Note any relevant and interesting events that happened while you wrote the code.
    *   e.g. things you learned, things that didn't go according to plan
*   [ ] Tag the last commit in this phase `implemented`


## Phase 3: Testing and Debugging (tag name `tested`)
*(30% of your effort)*

Deliver:

*   [ ] A set of test cases that you have personally run on your computer.
    *   Include a description of what happened for each test case.
    *   For any bugs discovered, describe their cause and remedy.
    *   Write your test cases in plain language such that a non-coder could run them and replicate your experience.
*   [ ] Tag the last commit in this phase `tested`


## Phase 4: Deployment (tag name `deployed`)
*(5% of your effort)*

Deliver:

*   [ ] Tag the last commit in this phase `deployed`
*   [ ] Your repository is pushed to GitLab.
*   [ ] **Verify** that your final commit was received by browsing to its project page on GitLab.
    *   Ensure the project's URL is correct.
    *   Review the project to ensure that all required files are present and in correct locations.
    *   Check that unwanted files have not been included.
    *   Make any final touches to documentation, including the Sprint Signature and this Plan.
*   [ ] **Validate** that your submission is complete and correct by cloning it to a new location on your computer and re-running it.
	*	Run your program from the command line so you can see how it will behave when your grader runs it.  **Running it in PyCharm is not good enough!**
    *   Run through your test cases to avoid nasty surprises.
    *   Check that your documentation files are all present.


## Phase 5: Maintenance

Spend a few minutes writing thoughtful answers to these questions.  They are meant to make you think about the long-term consequences of choices you made in this project.

Deliver:

*   [ ] Write brief and honest answers to these questions:
    *   What parts of your program are sloppily written and hard to understand?
        *   Are there parts of your program which you aren't quite sure how/why they work?
        *   If a bug is reported in a few months, how long would it take you to find the cause?
    *   Will your documentation make sense to...
        *   ...anybody besides yourself?
        *   ...yourself in six month's time?
    *   How easy will it be to add a new feature to this program in a year?
    *   Will your program continue to work after upgrading...
        *   ...your computer's hardware?
        *   ...the operating system?
        *   ...to the next version of Python?
*   [ ] Make one final commit and push your **completed** Software Development Plan to GitLab.
*   [ ] Respond to the **Assignment Reflection Survey** on Canvas.
